estimate_A0SD(Wobs)
Wobs <- c(0,0,0,0,0)
estimate_A0SD(Wobs)
Wobs <- c(0,0,0,0,0,1)
estimate_A0SD(Wobs)
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
Wobs <- rbind(c(0,0,0,0,0,1), c(1,2,3,2,3,5))
estimate_A0SD(Wobs)
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0 <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
class <- apply(Wobs, 1, classify_func)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
return(logA0_hat)
#global r2: 0.907
}
estimate_A0SD(Wobs)
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0 <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
class <- apply(Wobs, 1, classify_func)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
return(logA0_hat)
#global r2: 0.907
}
estimate_A0(Wobs)
estimate_logA0(Wobs)
Wobs
sd(c(0,0,0,0,0,1))
sd(c(log(NA), log(NA), log(NA), log(1)), na.rm = TRUE)
log(1)
estimate_logA0(Wobs)sd(c(0,0,0,))
sd(c(0,0,0,0))
sd(c(log(1), log(1), log(1)))
log(NA)
sd(log(1))
sd(NA, NA, NA, log(2))
sd(c(NA, NA, NA, log(2)))
sd(c(NA, NA, NA, log(2)), na.rm=TRUE)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
exp(-0.328504067)
#'Classify river for unsupervised framework
#'
#' @param Wobs observed widths matrix
classify_func_unsupervised <- function(Wobs) {
width <- median((Wobs), na.rm = TRUE) #note these are not log widths!
width_sd <- sd((Wobs), na.rm = TRUE)
#One-vs-Rest Logistic regression model
#test set accuracy rate of 87%
p_noise <- 1 / (1.0 + exp(-(-3.12907956 + 7.72682055e-04 * width_sd + 1.68285442e-03 * width)))
p_1 <- 1 / (1.0 + exp(-(1.9719785 + -7.08487404e-04 * width_sd + -9.57359172e-04 * width)))
p_2 <- 1 / (1.0 + exp(-(-4.0504766  + -1.30605126e-04 * width_sd + 1.60069188e-03 * width)))
p_3<- 1 / (1.0 + exp(-(-4.34955267 + -6.70236303e-03 * width_sd + 7.59492911e-05 * width)))
p_4 <- 1 / (1.0 + exp(-(-3.9977568  + 3.24040207e-04 * width_sd + 1.59933716e-03 * width)))
p_5 <- 1 / (1.0 + exp(-(-4.26058253 + -2.39296957e-03 * width_sd + -1.41460664e-02 * width)))
p_6 <- 1 / (1.0 + exp(-(-3.86984885 + -2.63864258e-04 * width_sd + -1.68608848e-03 * width)))
p_7 <- 1 / (1.0 + exp(-(-1.15978639 + 5.68264551e-04 * width_sd + -1.27528508e-01 * width)))
probs <- data.frame(p_noise, p_1, p_2, p_3, p_4, p_5, p_6, p_7)
index <- which.max(probs)
index <- ifelse(index == 1, 101, index-1) #101 for 'noisey' rivers
return(index)
}
wobs <- rbind(c(100,200,100), c(70,76,80), c(86,110,100))
classify_func_unsupervised(wobs)
#'Classify river for expert framework
#'
#'@param Wobs observed widths matrix
classify_func <- function(Wobs) {
lwbar <- mean(log(Wobs), na.rm=TRUE)
lwsd <- sd(log(Wobs), na.rm= TRUE)
maxWidth = 6.5
classes <- c(2.476118144,
2.864001065,
3.103015939,
3.249308032,
3.284178964,
3.371669039,
3.56827873,
3.664586762,
3.683922384,
4.002696788,
4.031559142,
4.357733942,
4.436574004,
4.921166637,
5.287893051) #median width of each river type
index <- ifelse(lwbar > maxWidth, 17, which.min(abs(classes-lwbar))) #17 for big rivers
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
return(index)
}
classify_func(wobs)
classify_func_unsupervised(wobs)
apply(wobs, 1, classify_func_unsupervised)
apply(wobs, 1, classify_func)
apply(wobs, 1, classify_func_unsupervised)
class <- apply(Wobs, 1, classify_func_unsupervised)
Wobs = wobs
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
#unsupervised classification
temp <- c(0.385262401,
2.05284086,
4.952299717,
5.059425458,
3.446807893,
1.596352673,
0.262364264)
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
wobs <- rbind(c(100,200,100), c(70,76,NA), c(86,110,100))
Wobs <- rbind(c(100,200,100), c(70,76,NA), c(86,110,100))
class <- apply(Wobs, 1, classify_func_unsupervised)
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
lowerbound_A0 <- min(lowerbound_A0, na.rm = TRUE)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
lowerbound_A0 <- min(lowerbound_A0, na.rm = TRUE)
#' Estimate base cross-sectional area lowerbound using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_lowerboundA0_unsupervised <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#unsupervised classification
temp <- c(0.385262401,
2.05284086,
4.952299717,
5.059425458,
3.446807893,
1.596352673,
0.262364264)
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
lowerbound_A0 <- min(lowerbound_A0, na.rm = TRUE)
}
estimate_lowerboundA0_unsupervised(Wobs)
t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,NA,NA), c(86,110,100))
t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,NA,300), c(86,110,100))
t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,320,300), c(86,110,100))
#' Options manager for geoBAMr defaults using unsupervised classification
#'
#' @param ... (Optional) named settings to query or set.
#' @param .__defaults See \code{?settings::option_manager}
#' @param .__reset See \code{?settings::option_manager}
#' @export
bam_settings_unsupervised <- settings::options_manager(
paramnames = c("lowerbound_logQ", "upperbound_logQ", "lowerbound_A0",
"upperbound_A0", "lowerbound_logn", "upperbound_logn", "lowerbound_logQc",
"upperbound_logQc", "lowerbound_logWc", "upperbound_logWc", "lowerbound_b",
"upperbound_b", "lowerbound_logWb", 'upperbound_logWb', 'lowerbound_logDb',
'upperbound_logDb', 'lowerbound_logr', 'upperbound_logr',
"sigma_man", "sigma_amhg",
"logQc_hat", "logWc_hat", "b_hat", "logA0_hat", "logn_hat", 'logWb_hat', 'logDb_hat', 'logr_hat',
"logQ_sd", "logQc_sd", "logWc_sd", "b_sd", "logA0_sd", "logn_sd", 'logWb_sd', 'logDb_sd', 'logr_sd',
"Werr_sd", "Serr_sd", "dAerr_sd",
'river_type'),
# Bounds on parameters
lowerbound_logQ = rlang::quo(maxmin(log(Wobs)) + log(0.5) + log(0.5)),
upperbound_logQ = rlang::quo(minmax(log(Wobs)) + log(40) + log(5)),
lowerbound_A0 = rlang::quo(estimate_lowerboundA0_unsupervised(Wobs)), #0.72,
upperbound_A0 = rlang::quo(estimate_upperboundA0_unsupervised(Wobs)), #114500,
lowerbound_logn = log(0.01), #rlang::quo(estimate_lowerboundlogn_unsupervised(Wobs)), #-4.60517,
upperbound_logn = log(0.05), #rlang::quo(estimate_upperboundlogn_unsupervised(Wobs)), #-2.995732,
lowerbound_logQc = 0.01,
upperbound_logQc = 10,
lowerbound_logWc = 1,
upperbound_logWc = 8, # 3 km
lowerbound_b = rlang::quo(estimate_lowerboundb_unsupervised(Wobs)), #0.000182,
upperbound_b = rlang::quo(estimate_upperboundb_unsupervised(Wobs)), #0.773758,
lowerbound_logDb = rlang::quo(estimate_lowerboundlogDb_unsupervised(Wobs)), #-3.02002,
upperbound_logDb = rlang::quo(estimate_upperboundlogDb_unsupervised(Wobs)), #3.309359,
lowerbound_logWb = rlang::quo(estimate_lowerboundlogWb_unsupervised(Wobs)),#-0.12273,
upperbound_logWb = rlang::quo(estimate_upperboundlogWb_unsupervised(Wobs)), #7.006786,
lowerbound_logr = rlang::quo(estimate_lowerboundlogr_unsupervised(Wobs)), #-2.58047,
upperbound_logr = rlang::quo(estimate_upperboundlogr_unsupervised(Wobs)), #8.03772,
# *Known* likelihood parameters
sigma_man = 0.25,
sigma_amhg = 0.22, # UPDATE THIS FROM CAITLINE'S WORK
# Hyperparameters
logQc_hat = rlang::quo(mean(logQ_hat)),
logWc_hat = rlang::quo(mean(log(Wobs))),
b_hat = rlang::quo(estimate_b_unsupervised(Wobs)),
logA0_hat = rlang::quo(estimate_logA0_unsupervised(Wobs)),
logn_hat = rlang::quo(estimate_logn_unsupervised(Sobs, Wobs)),
logWb_hat = rlang::quo(estimate_logWb_unsupervised(Wobs)),
logDb_hat = rlang::quo(estimate_logDb_unsupervised(Wobs)),
logr_hat = rlang::quo(estimate_logr_unsupervised(Wobs)),
logQ_sd = sqrt(log(1^2 + 1)), # CV of Q equals 1
logQc_sd = sqrt(log(1^2 + 1)), # CV of Q equals 1; UPDATE THIS
logWc_sd = sqrt(log(0.01)^2 + 1),
#set from my model outputs
b_sd = rlang::quo(estimate_bSD_unsupervised(Wobs)), #0.068077044,
logA0_sd = rlang::quo(estimate_A0SD_unsupervised(Wobs)), #0.58987527,
logn_sd = rlang::quo(estimate_lognSD_unsupervised(Wobs)), #0.761673112,
logWb_sd = rlang::quo(estimate_logWbSD_unsupervised(Wobs)), #0.137381044,
logDb_sd = rlang::quo(estimate_logDbSD_unsupervised(Wobs)), #0.576212733,
logr_sd = rlang::quo(estimate_logrSD_unsupervised(Wobs)), #0.67332688,
# Observation errors.
Werr_sd = 10,
Serr_sd = 1e-5,
dAerr_sd = 10,
#Classified river type
river_type = rlang::quo(apply(Wobs, 1, classify_func_unsupervised))
)
bam_settings_unsupervised(Wobs)
rm(bam_settings_unsupervised())
#A0 functions---------------------------------------------------------------
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0_unsupervised <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#unsupervised classification
temp <- c(5.538317552,
7.31986493,
8.157657015,
7.835974582,
5.329969058,
6.223916904,
3.019662854)
class <- apply(Wobs, 1, classify_func_unsupervised)
logA0_hat <- ifelse(class != 101, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
#global r2: 0.907
}
Wobs <- rbind(c(100,200,100), c(NA,320,300), c(86,110,100))
estimate_logA0_unsupervised(Wobs)
t <- estimate_logA0_unsupervised(Wobs)
low_t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,NA,300), c(86,110,100))
t <- estimate_logA0_unsupervised(Wobs)
#'Classify river for unsupervised framework
#'
#' @param Wobs observed widths matrix
classify_func_unsupervised <- function(Wobs) {
width <- median((Wobs), na.rm = TRUE) #note these are not log widths!
#One-vs-Rest Logistic regression model
#test set accuracy rate of 87%
p_noise <- 1 / (1.0 + exp(-(-3.11056777 + 0.00189261 * width)))
p_1 <- 1 / (1.0 + exp(-(1.95763357 + -0.00114445 * width)))
p_2 <- 1 / (1.0 + exp(-(-4.05274822 + 0.00156913 * width)))
p_3<- 1 / (1.0 + exp(-(-4.43158034 + -0.00116211 * width)))
p_4 <- 1 / (1.0 + exp(-(-3.99272449 + 0.00168791* width)))
p_5 <- 1 / (1.0 + exp(-(-4.28204232 + -0.01493184 * width)))
p_6 <- 1 / (1.0 + exp(-(-3.87408245 + -0.00175089 * width)))
p_7 <- 1 / (1.0 + exp(-(-1.16209678 + -0.12664823 * width)))
probs <- data.frame(p_noise, p_1, p_2, p_3, p_4, p_5, p_6, p_7)
index <- which.max(probs)
index <- ifelse(index == 1, 101, index-1) #101 for 'noisey' rivers
return(index)
}
t <- estimate_logA0_unsupervised(Wobs)
low_t <- estimate_lowerboundA0_unsupervised(Wobs)
classify_func_unsupervised(Wobs)
apply(Wobs, 1, classify_func_unsupervised)
View(Wobs)
pkgbuild::compile_dll() # see note beloapply(Wobs, 1, classify_func_unsupervised)
apply(Wobs, 1, classify_func_unsupervised)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
datalist <- list('Wobs'=W_obs, 'Sobs'=S_obs, 'Qhat'=qhat)
W_obs <- cbind(c(NA,75,55), c(58,70,56), c(59,72,56))
S_obs <- cbind(c(0.001, 0.0015, 0.001), c(0.002, NA, 0.002), c(0.002, 0.002, 0.004))
dA_obs <- cbind(c(10, 20, 10), c(15, 7, 15), c(15, 12, NA))
datalist <- list('Wobs'=W_obs, 'Sobs'=S_obs, 'Qhat'=qhat)
qhat <- as.vector(rep(500, ncol(W_obs)))
datalist <- list('Wobs'=W_obs, 'Sobs'=S_obs, 'Qhat'=qhat)
bam_data(W_obs, S_obs, dA=NULL, Qhat = qhat)
t <- bam_data(W_obs, S_obs, dA=NULL, Qhat = qhat)
View(t)
t$hasdat_amhg
t$hasdat_man
t$Wobs
t$Sobs
t$dAobs
t <- bam_data(W_obs, Qhat = qhat)
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(W_obs, Qhat = qhat)
t <- bam_data(W_obs, S_obs, Qhat = qhat)
t$hasdat_amhg
t$hasdat_man
t <- bam_data(W_obs, S_obs, dA_obs, Qhat = qhat)
t$hasdat_man
t$hasdat_amhg
t$Wobs
mean(log(t$Wobs))
maxmin(log(t$Wobs)) + log(0.5) + log(0.5)
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(W_obs, S_obs, dA_obs, Qhat = qhat)
t$hasdat_amhg
t$hasdat_man
source('~/GitHub/geoBAMr/R/priorCalc.R', echo=TRUE)
tpriors <- bam_priors(t)
source('~/GitHub/geoBAMr/R/bam_settings.R', echo=TRUE)
tpriors <- bam_priors(t)
source('~/GitHub/geoBAMr/R/utils.R', echo=TRUE)
tpriors <- bam_priors(t)
View(tpriors)
View(tpriors, logWc_hat = 4)
tpriors <- bam_priors(t, logWc=4)
tpriors <- bam_priors(t, logWc_hat=4)
View(tpriors)
source('~/GitHub/geoBAMr/R/estimate.R', echo=TRUE)
tfin <- bam_estimate(t, bampriors = tpriors)
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
W_obs <- cbind(c(NA,75,55), c(58,70,56), c(59,72,56))
S_obs <- cbind(c(0.001, 0.0015, 0.001), c(0.002, NA, 0.002), c(0.002, 0.002, 0.004))
dA_obs <- cbind(c(10, 20, 10), c(15, 7, 15), c(15, 12, NA))
bamdata <- bam_data(w=W_obs, s=S_obs, dA= dA_obs, Qhat=qhat)
qhat <- as.vector(rep(500, ncol(W_obs)))
bamdata <- bam_data(w=W_obs, s=S_obs, dA= dA_obs, Qhat=qhat)
bamdata$hasdat_man
bamdata <- bam_data(w=W_obs, dA= dA_obs, Qhat=qhat)
dA_obs <- cbind(c(10, 20, 10), c(15, 7, 15), c(15, 12, NA))
variant = 'amhg'
dA <- dA_obs# datalist$dA
if(!dA & variant == 'amhg')
if(dA && variant == 'amhg')
if(is(dA) && is(variant == 'amhg'))
is(dA) && is(variant == 'amhg')
is(dA) & is(variant == 'amhg')
exists(dA)
exists(dA)
exists('dA')
if(exists('dA') & is(variant == 'amhg'))
if(exists('dA') & is(variant == 'amhg')){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
if(exists('dA')){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
if(exists('dA'&& (variant == 'amhg'))){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
if(exists('dA'&& variant == 'amhg')){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
vara=iant == 'amhg'
varaiant == 'amhg'
variant == 'amhg'
var <- variant == 'amhg'
var <- variant == 'amhg'
if(exists('dA'&& variant)){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
if(exists('dA'&& variant==T)){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
if(exists('dA')&& variant==T)){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
if(exists('dA')&& variant==T){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
if(exists('dA')&& variant=='amhg'){
stop('AMHG-only geoBAM cannot process a dA matrix!')}
W_obs <- cbind(c(NA,75,55), c(58,70,56), c(59,72,56))
S_obs <- cbind(c(0.001, 0.0015, 0.001), c(0.002, NA, 0.002), c(0.002, 0.002, 0.004))
dA_obs <- cbind(c(10, 20, 10), c(15, 7, 15), c(15, 12, NA))
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
qhat <- as.vector(rep(500, ncol(W_obs)))
t <- bam_data(w=W_obs, s=S_obs, variant = 'amhg', Qhat = Qhat)
t <- bam_data(w=W_obs, s=S_obs, variant = 'amhg', Qhat = qhat)
rm(dA)
t <- bam_data(w=W_obs, s=S_obs, variant = 'amhg', Qhat = qhat)
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(w=W_obs, s=S_obs, variant = 'amhg', Qhat = qhat)
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(w=W_obs, s=S_obs, variant = 'amhg', Qhat = qhat)
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(w=W_obs, s=S_obs, variant = 'amhg', Qhat = qhat)
View(t)
t$dAobs
t <- bam_data(w=W_obs, s=S_obs, variant = 'manning_amhg', Qhat = qhat)
View(t)
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(w=W_obs, s=S_obs, variant = 'manning_amhg', Qhat = qhat)
t <- bam_data(w=W_obs, s=S_obs, variant = 'manning', Qhat = qhat)
t <- bam_data(w=W_obs, s=S_obs, dA=dA_obs, variant = 'amhg', Qhat = qhat)
t <- bam_data(w=W_obs, s=S_obs, variant = 'amhg', Qhat = qhat)
t$Sobs
t$Wobs
t$hasdat_amhg
t$hasdat_man
View(t)
t <- bam_data(w=W_obs, s=S_obs, dA=dA_obs, variant = 'manning', Qhat = qhat)
t$Wobs
t$Sobs
t$dAobs
t$ntot_amhg
t$ntot_man
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(w=W_obs, s=S_obs, dA=dA_obs, variant = 'manning', Qhat = qhat)
t$Sobs
t$ntot_amhg
t$ntot_man
t$Wobs
t$dAobs
t <- bam_data(w=W_obs, s=S_obs, dA=dA_obs, variant = 'manning_amhg', Qhat = qhat)
t$Wobs
t$Sobs
t$dAobs
t$hasdat_amhg
t$hasdat_man
source('~/GitHub/geoBAMr/R/dataprep.R', echo=TRUE)
t <- bam_data(w=W_obs, s=S_obs, dA=dA_obs, variant = 'manning_amhg', Qhat = qhat)
t$Wobs
t$Sobs
t$dAobs
t$hasdat_man
t$hasdat_amhg
t$Sobs
#Fit stan model----------------------------------------------------
fit1 <- stan(
file = "C:\\Users\\craig\\Documents\\GitHub\\geoBAMr\\inst\\stan\\master.stan",
data=t,
chains=3,
iter=3000,
cores=getOption("mc.cores", default = parallel::detectCores()),
control = list(adapt_delta=0.95)
)
library(rstan)
#Fit stan model----------------------------------------------------
fit1 <- stan(
file = "C:\\Users\\craig\\Documents\\GitHub\\geoBAMr\\inst\\stan\\master.stan",
data=t,
chains=3,
iter=3000,
cores=getOption("mc.cores", default = parallel::detectCores()),
control = list(adapt_delta=0.95)
)
t$hasdat_amhg
source('~/GitHub/geoBAMr/R/bam_settings.R', echo=TRUE)
source('~/GitHub/geoBAMr/R/estimate.R', echo=TRUE)
source('~/GitHub/geoBAMr/R/priorCalc.R', echo=TRUE)
t <- bam_data(w=W_obs, s=S_obs, dA=dA_obs, variant = 'manning_amhg', Qhat = qhat)
t_priors <- bam_priors(t)
source('~/GitHub/geoBAMr/R/utils.R', echo=TRUE)
t_priors <- bam_priors(t)
View(t_priors)
t_priors <- bam_priors(t, logWc_hat = 3)
qpred <- bam_estimate(t, variant='manning_amhg', bampriors = t_priors)
source('~/GitHub/geoBAMr/R/stanmodels.R', echo=TRUE)
qpred <- bam_estimate(t, variant='manning_amhg', bampriors = t_priors)
source('~/GitHub/geoBAMr/R/zzz.R', echo=TRUE)
qpred <- bam_estimate(t, variant='manning_amhg', bampriors = t_priors)
t$hasdat_amhg
t$hasdat_man
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
