Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
#Global r2: 0.421
}
estimate_logr(Wobs)
#'Estimate channel shape using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logr <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
#Global r2: 0.421
}
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(24,23,200))
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(700,200,200))
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(700,900,700))
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(700,900,NA))
exp(0.599)
index <- 17
lwsd <- 0.50
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
index <- 17
lwsd <- 0.2
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
class <- c(15,16,17,16)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
lwsd <- .45
lwsd <- <- c(.45, .3, .24, .5)
lwsd <- c(.45, .3, .24, .5)
lwbar <- c(4,5,,6.6,6)
lwbar <- c(4,5,6.6,6)
lwsd <- c(.45, .50,.4,.5)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
c(NA, NA, NA, NA)
Wobs <- c(NA, NA, NA, NA)
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
#' Estimate base cross-sectional area SD using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_A0SD <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(1.446820524,
1.350055707,
1.363875688,
1.260787706,
1.306619211,
1.315826017,
1.190542029,
1.337220271,
1.21047899,
1.359096608,
1.245863462,
1.287297345,
1.08535437,
1.154319081,
1.5575699,
2.272342301)
class <- apply(Wobs, 1, classify_func)
logA0_sd <- ifelse(class != 17, temp[class], 0.58987527)
}
estimate_A0SD(Wobs)
Wobs <- c(0,0,0,0,0)
estimate_A0SD(Wobs)
Wobs <- c(0,0,0,0,0,1)
estimate_A0SD(Wobs)
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
Wobs <- rbind(c(0,0,0,0,0,1), c(1,2,3,2,3,5))
estimate_A0SD(Wobs)
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0 <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
class <- apply(Wobs, 1, classify_func)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
return(logA0_hat)
#global r2: 0.907
}
estimate_A0SD(Wobs)
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0 <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
class <- apply(Wobs, 1, classify_func)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
return(logA0_hat)
#global r2: 0.907
}
estimate_A0(Wobs)
estimate_logA0(Wobs)
Wobs
sd(c(0,0,0,0,0,1))
sd(c(log(NA), log(NA), log(NA), log(1)), na.rm = TRUE)
log(1)
estimate_logA0(Wobs)sd(c(0,0,0,))
sd(c(0,0,0,0))
sd(c(log(1), log(1), log(1)))
log(NA)
sd(log(1))
sd(NA, NA, NA, log(2))
sd(c(NA, NA, NA, log(2)))
sd(c(NA, NA, NA, log(2)), na.rm=TRUE)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
exp(-0.328504067)
#'Classify river for unsupervised framework
#'
#' @param Wobs observed widths matrix
classify_func_unsupervised <- function(Wobs) {
width <- median((Wobs), na.rm = TRUE) #note these are not log widths!
width_sd <- sd((Wobs), na.rm = TRUE)
#One-vs-Rest Logistic regression model
#test set accuracy rate of 87%
p_noise <- 1 / (1.0 + exp(-(-3.12907956 + 7.72682055e-04 * width_sd + 1.68285442e-03 * width)))
p_1 <- 1 / (1.0 + exp(-(1.9719785 + -7.08487404e-04 * width_sd + -9.57359172e-04 * width)))
p_2 <- 1 / (1.0 + exp(-(-4.0504766  + -1.30605126e-04 * width_sd + 1.60069188e-03 * width)))
p_3<- 1 / (1.0 + exp(-(-4.34955267 + -6.70236303e-03 * width_sd + 7.59492911e-05 * width)))
p_4 <- 1 / (1.0 + exp(-(-3.9977568  + 3.24040207e-04 * width_sd + 1.59933716e-03 * width)))
p_5 <- 1 / (1.0 + exp(-(-4.26058253 + -2.39296957e-03 * width_sd + -1.41460664e-02 * width)))
p_6 <- 1 / (1.0 + exp(-(-3.86984885 + -2.63864258e-04 * width_sd + -1.68608848e-03 * width)))
p_7 <- 1 / (1.0 + exp(-(-1.15978639 + 5.68264551e-04 * width_sd + -1.27528508e-01 * width)))
probs <- data.frame(p_noise, p_1, p_2, p_3, p_4, p_5, p_6, p_7)
index <- which.max(probs)
index <- ifelse(index == 1, 101, index-1) #101 for 'noisey' rivers
return(index)
}
wobs <- rbind(c(100,200,100), c(70,76,80), c(86,110,100))
classify_func_unsupervised(wobs)
#'Classify river for expert framework
#'
#'@param Wobs observed widths matrix
classify_func <- function(Wobs) {
lwbar <- mean(log(Wobs), na.rm=TRUE)
lwsd <- sd(log(Wobs), na.rm= TRUE)
maxWidth = 6.5
classes <- c(2.476118144,
2.864001065,
3.103015939,
3.249308032,
3.284178964,
3.371669039,
3.56827873,
3.664586762,
3.683922384,
4.002696788,
4.031559142,
4.357733942,
4.436574004,
4.921166637,
5.287893051) #median width of each river type
index <- ifelse(lwbar > maxWidth, 17, which.min(abs(classes-lwbar))) #17 for big rivers
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
return(index)
}
classify_func(wobs)
classify_func_unsupervised(wobs)
apply(wobs, 1, classify_func_unsupervised)
apply(wobs, 1, classify_func)
apply(wobs, 1, classify_func_unsupervised)
class <- apply(Wobs, 1, classify_func_unsupervised)
Wobs = wobs
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
#unsupervised classification
temp <- c(0.385262401,
2.05284086,
4.952299717,
5.059425458,
3.446807893,
1.596352673,
0.262364264)
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
wobs <- rbind(c(100,200,100), c(70,76,NA), c(86,110,100))
Wobs <- rbind(c(100,200,100), c(70,76,NA), c(86,110,100))
class <- apply(Wobs, 1, classify_func_unsupervised)
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
lowerbound_A0 <- min(lowerbound_A0, na.rm = TRUE)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
lowerbound_A0 <- min(lowerbound_A0, na.rm = TRUE)
#' Estimate base cross-sectional area lowerbound using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_lowerboundA0_unsupervised <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#unsupervised classification
temp <- c(0.385262401,
2.05284086,
4.952299717,
5.059425458,
3.446807893,
1.596352673,
0.262364264)
class <- apply(Wobs, 1, classify_func_unsupervised)
lowerbound_A0 <- ifelse(class != 101, exp(temp[class]), exp(-0.328504067))
lowerbound_A0 <- min(lowerbound_A0, na.rm = TRUE)
}
estimate_lowerboundA0_unsupervised(Wobs)
t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,NA,NA), c(86,110,100))
t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,NA,300), c(86,110,100))
t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,320,300), c(86,110,100))
#' Options manager for geoBAMr defaults using unsupervised classification
#'
#' @param ... (Optional) named settings to query or set.
#' @param .__defaults See \code{?settings::option_manager}
#' @param .__reset See \code{?settings::option_manager}
#' @export
bam_settings_unsupervised <- settings::options_manager(
paramnames = c("lowerbound_logQ", "upperbound_logQ", "lowerbound_A0",
"upperbound_A0", "lowerbound_logn", "upperbound_logn", "lowerbound_logQc",
"upperbound_logQc", "lowerbound_logWc", "upperbound_logWc", "lowerbound_b",
"upperbound_b", "lowerbound_logWb", 'upperbound_logWb', 'lowerbound_logDb',
'upperbound_logDb', 'lowerbound_logr', 'upperbound_logr',
"sigma_man", "sigma_amhg",
"logQc_hat", "logWc_hat", "b_hat", "logA0_hat", "logn_hat", 'logWb_hat', 'logDb_hat', 'logr_hat',
"logQ_sd", "logQc_sd", "logWc_sd", "b_sd", "logA0_sd", "logn_sd", 'logWb_sd', 'logDb_sd', 'logr_sd',
"Werr_sd", "Serr_sd", "dAerr_sd",
'river_type'),
# Bounds on parameters
lowerbound_logQ = rlang::quo(maxmin(log(Wobs)) + log(0.5) + log(0.5)),
upperbound_logQ = rlang::quo(minmax(log(Wobs)) + log(40) + log(5)),
lowerbound_A0 = rlang::quo(estimate_lowerboundA0_unsupervised(Wobs)), #0.72,
upperbound_A0 = rlang::quo(estimate_upperboundA0_unsupervised(Wobs)), #114500,
lowerbound_logn = log(0.01), #rlang::quo(estimate_lowerboundlogn_unsupervised(Wobs)), #-4.60517,
upperbound_logn = log(0.05), #rlang::quo(estimate_upperboundlogn_unsupervised(Wobs)), #-2.995732,
lowerbound_logQc = 0.01,
upperbound_logQc = 10,
lowerbound_logWc = 1,
upperbound_logWc = 8, # 3 km
lowerbound_b = rlang::quo(estimate_lowerboundb_unsupervised(Wobs)), #0.000182,
upperbound_b = rlang::quo(estimate_upperboundb_unsupervised(Wobs)), #0.773758,
lowerbound_logDb = rlang::quo(estimate_lowerboundlogDb_unsupervised(Wobs)), #-3.02002,
upperbound_logDb = rlang::quo(estimate_upperboundlogDb_unsupervised(Wobs)), #3.309359,
lowerbound_logWb = rlang::quo(estimate_lowerboundlogWb_unsupervised(Wobs)),#-0.12273,
upperbound_logWb = rlang::quo(estimate_upperboundlogWb_unsupervised(Wobs)), #7.006786,
lowerbound_logr = rlang::quo(estimate_lowerboundlogr_unsupervised(Wobs)), #-2.58047,
upperbound_logr = rlang::quo(estimate_upperboundlogr_unsupervised(Wobs)), #8.03772,
# *Known* likelihood parameters
sigma_man = 0.25,
sigma_amhg = 0.22, # UPDATE THIS FROM CAITLINE'S WORK
# Hyperparameters
logQc_hat = rlang::quo(mean(logQ_hat)),
logWc_hat = rlang::quo(mean(log(Wobs))),
b_hat = rlang::quo(estimate_b_unsupervised(Wobs)),
logA0_hat = rlang::quo(estimate_logA0_unsupervised(Wobs)),
logn_hat = rlang::quo(estimate_logn_unsupervised(Sobs, Wobs)),
logWb_hat = rlang::quo(estimate_logWb_unsupervised(Wobs)),
logDb_hat = rlang::quo(estimate_logDb_unsupervised(Wobs)),
logr_hat = rlang::quo(estimate_logr_unsupervised(Wobs)),
logQ_sd = sqrt(log(1^2 + 1)), # CV of Q equals 1
logQc_sd = sqrt(log(1^2 + 1)), # CV of Q equals 1; UPDATE THIS
logWc_sd = sqrt(log(0.01)^2 + 1),
#set from my model outputs
b_sd = rlang::quo(estimate_bSD_unsupervised(Wobs)), #0.068077044,
logA0_sd = rlang::quo(estimate_A0SD_unsupervised(Wobs)), #0.58987527,
logn_sd = rlang::quo(estimate_lognSD_unsupervised(Wobs)), #0.761673112,
logWb_sd = rlang::quo(estimate_logWbSD_unsupervised(Wobs)), #0.137381044,
logDb_sd = rlang::quo(estimate_logDbSD_unsupervised(Wobs)), #0.576212733,
logr_sd = rlang::quo(estimate_logrSD_unsupervised(Wobs)), #0.67332688,
# Observation errors.
Werr_sd = 10,
Serr_sd = 1e-5,
dAerr_sd = 10,
#Classified river type
river_type = rlang::quo(apply(Wobs, 1, classify_func_unsupervised))
)
bam_settings_unsupervised(Wobs)
rm(bam_settings_unsupervised())
#A0 functions---------------------------------------------------------------
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0_unsupervised <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#unsupervised classification
temp <- c(5.538317552,
7.31986493,
8.157657015,
7.835974582,
5.329969058,
6.223916904,
3.019662854)
class <- apply(Wobs, 1, classify_func_unsupervised)
logA0_hat <- ifelse(class != 101, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
#global r2: 0.907
}
Wobs <- rbind(c(100,200,100), c(NA,320,300), c(86,110,100))
estimate_logA0_unsupervised(Wobs)
t <- estimate_logA0_unsupervised(Wobs)
low_t <- estimate_lowerboundA0_unsupervised(Wobs)
Wobs <- rbind(c(100,200,100), c(NA,NA,300), c(86,110,100))
t <- estimate_logA0_unsupervised(Wobs)
#'Classify river for unsupervised framework
#'
#' @param Wobs observed widths matrix
classify_func_unsupervised <- function(Wobs) {
width <- median((Wobs), na.rm = TRUE) #note these are not log widths!
#One-vs-Rest Logistic regression model
#test set accuracy rate of 87%
p_noise <- 1 / (1.0 + exp(-(-3.11056777 + 0.00189261 * width)))
p_1 <- 1 / (1.0 + exp(-(1.95763357 + -0.00114445 * width)))
p_2 <- 1 / (1.0 + exp(-(-4.05274822 + 0.00156913 * width)))
p_3<- 1 / (1.0 + exp(-(-4.43158034 + -0.00116211 * width)))
p_4 <- 1 / (1.0 + exp(-(-3.99272449 + 0.00168791* width)))
p_5 <- 1 / (1.0 + exp(-(-4.28204232 + -0.01493184 * width)))
p_6 <- 1 / (1.0 + exp(-(-3.87408245 + -0.00175089 * width)))
p_7 <- 1 / (1.0 + exp(-(-1.16209678 + -0.12664823 * width)))
probs <- data.frame(p_noise, p_1, p_2, p_3, p_4, p_5, p_6, p_7)
index <- which.max(probs)
index <- ifelse(index == 1, 101, index-1) #101 for 'noisey' rivers
return(index)
}
t <- estimate_logA0_unsupervised(Wobs)
low_t <- estimate_lowerboundA0_unsupervised(Wobs)
classify_func_unsupervised(Wobs)
apply(Wobs, 1, classify_func_unsupervised)
View(Wobs)
pkgbuild::compile_dll() # see note beloapply(Wobs, 1, classify_func_unsupervised)
apply(Wobs, 1, classify_func_unsupervised)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
