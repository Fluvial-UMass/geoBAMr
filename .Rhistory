NHD_HR_merged.df$CaelVol_m3 <- 0.533 * (NHD_HR_merged.df$LakeAreaSqKm*1000000)^1.204 #Cael et al. 2016
NHD_HR_merged.df <- select(NHD_HR_merged.df, Permanent_Identifier, NHDPlusID, LengthKM, FlowDir, WBArea_Permanent_Identifier,
StreamOrde, FromNode, ToNode, HydroSeq, Divergence, StartFlag, AreaSqKm.x, TotDASqKm, DivDASqKm,
Slope, QEMA, VEMA, LakeAreaSqKm, LakeVol_m3, CaelVol_m3)
NHD_HR_merged.df$LakeVol_m3 <- ifelse(NHD_HR_merged.df$LakeAreaSqKm < 0.1, #if lake is too small (< 0.1 skm), then run Cael's Adriodacks model as its the most regionally similar
ifelse(NHD_HR_merged.df$LakeAreaSqKm == 0, 0, (0.425*(NHD_HR_merged.df$LakeAreaSqKm*1000000)^1.239)), NHD_HR_merged.df$LakeVol_m3)
sumThroughFlow <- filter(NHD_HR_merged.df, is.na(WBArea_Permanent_Identifier)==0) %>%
group_by(WBArea_Permanent_Identifier) %>%
summarise(sumThroughFlow = sum(LengthKM))
NHD_HR_merged.df <- left_join(NHD_HR_merged.df, sumThroughFlow, by='WBArea_Permanent_Identifier')
NHD_HR_merged.df$lakePercent <- NHD_HR_merged.df$LengthKM / NHD_HR_merged.df$sumThroughFlow
NHD_HR_merged.df$frac_lakeVol_m3 <- NHD_HR_merged.df$LakeVol_m3 * NHD_HR_merged.df$lakePercent
NHD_HR_merged.df$frac_CaelVol_m3 <- NHD_HR_merged.df$CaelVol_m3 * NHD_HR_merged.df$lakePercent
NHD_HR_merged.df$waterbody <- ifelse(is.na(NHD_HR_merged.df$WBArea_Permanent_Identifier)==0 & is.na(NHD_HR_merged.df$LakeAreaSqKm) == 0 & NHD_HR_merged.df$LakeAreaSqKm > 0, 'Lake/Reservoir', 'River')
write.table(NHD_HR_merged.df, 'NHD_gasTransfer_CT.txt', sep='\t')
}
#load in data---------------------------------------------------
gasTransfer <- read.table('NHD_gasTransfer_CT.txt', sep='\t')
#filter for channels with routed Q
channels <- read.table("C:\\Users\\craig\\Box Sync\\Ongoing Projects\\Watershed_Rules_of_Life\\Routing\\working\\channels.txt", sep = "" , header = FALSE)
colnames(channels)[colnames(channels)=="V12"] <- "n"
colnames(channels)[colnames(channels)=="V13"] <- "Width"
colnames(channels)[colnames(channels)=="V15"] <- "NHDPlusID"
View(channels)
channels <- channels[,c(12,13,15)]
getwd()
write.csv(channels, 'widths.csv')
#filter for channels with routed Q
channels <- read.table("C:\\Users\\craig\\Box Sync\\Ongoing Projects\\Watershed_Rules_of_Life\\Routing\\working\\channels.txt", sep = "" , header = FALSE)
colnames(channels)[colnames(channels)=="V13"] <- "Width"
colnames(channels)[colnames(channels)=="V15"] <- "NHDPlusID"
View(channels)
channels <- channels[,c(13,15)]
View(channels)
write.csv(channels, 'widths.csv')
getwd
getwd()
rm(channels)
#'Classify river for expert framework
#'
#'@param Wobs observed widths matrix
classify_func <- function(Wobs) {
lwbar <- mean(log(Wobs), na.rm=TRUE)#apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- sd(log(Wobs), na.rm= TRUE)#apply(log(Wobs), 1, sd, na.rm = TRUE)
maxWidth = 6.5
classes <- c(2.476118144,
2.864001065,
3.103015939,
3.249308032,
3.284178964,
3.371669039,
3.56827873,
3.664586762,
3.683922384,
4.002696788,
4.031559142,
4.357733942,
4.436574004,
4.921166637,
5.287893051) #median width of each river type
index <- ifelse(lwbar > maxWidth, 17, which.min(abs(classes-lwbar))) #17 for big rivers
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
}
x <- cbind(c(40,30,40), c(30,34,35), c(50,40,40))
classify_func(x)
#'Classify river for expert framework
#'
#'@param Wobs observed widths matrix
classify_func <- function(Wobs) {
lwbar <- mean(log(Wobs), na.rm=TRUE)#apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- sd(log(Wobs), na.rm= TRUE)#apply(log(Wobs), 1, sd, na.rm = TRUE)
maxWidth = 6.5
classes <- c(2.476118144,
2.864001065,
3.103015939,
3.249308032,
3.284178964,
3.371669039,
3.56827873,
3.664586762,
3.683922384,
4.002696788,
4.031559142,
4.357733942,
4.436574004,
4.921166637,
5.287893051) #median width of each river type
index <- ifelse(lwbar > maxWidth, 17, which.min(abs(classes-lwbar))) #17 for big rivers
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
return(index)
}
classify_func(x)
x <- x[1,]
classify_func(x)
#'Classify river for unsupervised framework
#'
#' @param Wobs observed widths matrix
classify_func_unsupervised <- function(Wobs) {
width <- median((Wobs)) #note these are not log widths!
width_sd <- sd((Wobs))
#One-vs-Rest Logistic regression model
#test set accuracy rate of 87%
p_noise <- 1 / (1.0 + exp(-(-3.12907956 + 7.72682055e-04 * width_sd + 1.68285442e-03 * width)))
p_1 <- 1 / (1.0 + exp(-(1.9719785 + -7.08487404e-04 * width_sd + -9.57359172e-04 * width)))
p_2 <- 1 / (1.0 + exp(-(-4.0504766  + -1.30605126e-04 * width_sd + 1.60069188e-03 * width)))
p_3<- 1 / (1.0 + exp(-(-4.34955267 + -6.70236303e-03 * width_sd + 7.59492911e-05 * width)))
p_4 <- 1 / (1.0 + exp(-(-3.9977568  + 3.24040207e-04 * width_sd + 1.59933716e-03 * width)))
p_5 <- 1 / (1.0 + exp(-(-4.26058253 + -2.39296957e-03 * width_sd + -1.41460664e-02 * width)))
p_6 <- 1 / (1.0 + exp(-(-3.86984885 + -2.63864258e-04 * width_sd + -1.68608848e-03 * width)))
p_7 <- 1 / (1.0 + exp(-(-1.15978639 + 5.68264551e-04 * width_sd + -1.27528508e-01 * width)))
probs <- data.frame(p_noise, p_1, p_2, p_3, p_4, p_5, p_6, p_7)
index <- which.max(probs)
index <- ifelse(index == 1, 101, index-1) #101 for 'noisey' rivers
return(index)
}
classify_func_unsupervised(x)
x = Wobs
Wobs <- x
width <- median((Wobs)) #note these are not log widths!
width_sd <- sd((Wobs))
#One-vs-Rest Logistic regression model
#test set accuracy rate of 87%
p_noise <- 1 / (1.0 + exp(-(-3.12907956 + 7.72682055e-04 * width_sd + 1.68285442e-03 * width)))
p_1 <- 1 / (1.0 + exp(-(1.9719785 + -7.08487404e-04 * width_sd + -9.57359172e-04 * width)))
p_2 <- 1 / (1.0 + exp(-(-4.0504766  + -1.30605126e-04 * width_sd + 1.60069188e-03 * width)))
p_3<- 1 / (1.0 + exp(-(-4.34955267 + -6.70236303e-03 * width_sd + 7.59492911e-05 * width)))
p_4 <- 1 / (1.0 + exp(-(-3.9977568  + 3.24040207e-04 * width_sd + 1.59933716e-03 * width)))
p_5 <- 1 / (1.0 + exp(-(-4.26058253 + -2.39296957e-03 * width_sd + -1.41460664e-02 * width)))
p_6 <- 1 / (1.0 + exp(-(-3.86984885 + -2.63864258e-04 * width_sd + -1.68608848e-03 * width)))
p_7 <- 1 / (1.0 + exp(-(-1.15978639 + 5.68264551e-04 * width_sd + -1.27528508e-01 * width)))
probs <- data.frame(p_noise, p_1, p_2, p_3, p_4, p_5, p_6, p_7)
View(probs)
index <- which.max(probs)
index
index[,1]
index[1]
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
usethis::use_pkgdown()
pkgdown::build_site()
exp(4.540631665)
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
pkgbuild::compile_dll() # see note below
pkgbuild::compile_dll() # see note below
pkgbuild::compile_dll() # see note below
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
pkgbuild::compile_dll() # see note below
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
library(rstan)
library(rstantools)
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
library("rstantools")
pkgbuild::compile_dll() # see note below
library(rstantools)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
W_obs <0 rbind(c(20, 30,30), c(NA, 50,55), c(24,23,34))
W_obs <- rbind(c(20, 30,30), c(NA, 50,55), c(24,23,34))
View(W_obs)
Wobs <- W_obs
lwbar <- mean(log(Wobs), na.rm=TRUE)
lwsd <- sd(log(Wobs), na.rm= TRUE)
maxWidth = 6.5
classes <- c(2.476118144,
2.864001065,
3.103015939,
3.249308032,
3.284178964,
3.371669039,
3.56827873,
3.664586762,
3.683922384,
4.002696788,
4.031559142,
4.357733942,
4.436574004,
4.921166637,
5.287893051) #median width of each river type
index <- ifelse(lwbar > maxWidth, 17, which.min(abs(classes-lwbar))) #17 for big rivers
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
#'Classify river for expert framework
#'
#'@param Wobs observed widths matrix
classify_func <- function(Wobs) {
lwbar <- mean(log(Wobs), na.rm=TRUE)
lwsd <- sd(log(Wobs), na.rm= TRUE)
maxWidth = 6.5
classes <- c(2.476118144,
2.864001065,
3.103015939,
3.249308032,
3.284178964,
3.371669039,
3.56827873,
3.664586762,
3.683922384,
4.002696788,
4.031559142,
4.357733942,
4.436574004,
4.921166637,
5.287893051) #median width of each river type
index <- ifelse(lwbar > maxWidth, 17, which.min(abs(classes-lwbar))) #17 for big rivers
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
return(index)
}
rlang::quo(apply(Wobs, 1, classify_func))
apply(Wobs, 1, classify_func)
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(24,23,34))
apply(Wobs, 1, classify_func)
#'Estimate channel shape using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logr <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
#Global r2: 0.421
}
estimate_logr(Wobs)
#'Estimate channel shape using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logr <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
#Global r2: 0.421
}
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(24,23,200))
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(700,200,200))
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(700,900,700))
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(0.479582219,
0.475424989,
0.742030366,
0.747458374,
0.810066771,
0.764035146,
0.728537155,
0.914703855,
1.012946569,
1.012082534,
0.964521619,
1.007259927,
1.368493142,
1.217111712,
1.067996942,
-0.247245593)
class <- apply(Wobs, 1, classify_func)
logr_hat <- ifelse(class != 17, temp[class], 1.4241 - 1.9097 * lwsd + 0.0420 * lwbar) #repeat for each spatial unit
Wobs <- rbind(c(20, 30,30), c(NA, 5,55), c(700,900,NA))
exp(0.599)
index <- 17
lwsd <- 0.50
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
index <- 17
lwsd <- 0.2
index <- ifelse(lwsd >= 0.45, 16, index)  #16 for width-variable rivers, which overrides 'big' rivers
class <- c(15,16,17,16)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
lwsd <- .45
lwsd <- <- c(.45, .3, .24, .5)
lwsd <- c(.45, .3, .24, .5)
lwbar <- c(4,5,,6.6,6)
lwbar <- c(4,5,6.6,6)
lwsd <- c(.45, .50,.4,.5)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
c(NA, NA, NA, NA)
Wobs <- c(NA, NA, NA, NA)
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
#' Estimate base cross-sectional area SD using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_A0SD <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#expert classification
temp <- c(1.446820524,
1.350055707,
1.363875688,
1.260787706,
1.306619211,
1.315826017,
1.190542029,
1.337220271,
1.21047899,
1.359096608,
1.245863462,
1.287297345,
1.08535437,
1.154319081,
1.5575699,
2.272342301)
class <- apply(Wobs, 1, classify_func)
logA0_sd <- ifelse(class != 17, temp[class], 0.58987527)
}
estimate_A0SD(Wobs)
Wobs <- c(0,0,0,0,0)
estimate_A0SD(Wobs)
Wobs <- c(0,0,0,0,0,1)
estimate_A0SD(Wobs)
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
Wobs <- rbind(c(0,0,0,0,0,1), c(1,2,3,2,3,5))
estimate_A0SD(Wobs)
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0 <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
class <- apply(Wobs, 1, classify_func)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
return(logA0_hat)
#global r2: 0.907
}
estimate_A0SD(Wobs)
#' Estimate base cross-sectional area using bam data
#'
#' @param Wobs Observed W,as a space-down, time-across matrix.
#' @export
estimate_logA0 <- function(Wobs) {
Wobs[Wobs <= 0] <- NA # I replaced missing values with 0 so Stan will accept
lwbar <- apply(log(Wobs), 1, mean, na.rm = TRUE)
lwsd <- apply(log(Wobs), 1, sd, na.rm = TRUE)
#Expert classification
temp <- c(3.723280881,
4.497073804,
4.753590191,
4.990432587,
4.911328517,
5.350615603,
5.422742508,
5.523458921,
5.774532256,
6.446836611,
6.527953643,
6.873163834,
7.102499356,
8.007965013,
8.937204637,
4.432006567)
class <- apply(Wobs, 1, classify_func)
logA0_hat <- ifelse(class != 17, temp[class], -0.2918 + 1.6930 * lwbar - 0.1887 * lwsd) #repeat for each sptial unit
return(logA0_hat)
#global r2: 0.907
}
estimate_A0(Wobs)
estimate_logA0(Wobs)
Wobs
sd(c(0,0,0,0,0,1))
sd(c(log(NA), log(NA), log(NA), log(1)), na.rm = TRUE)
log(1)
estimate_logA0(Wobs)sd(c(0,0,0,))
sd(c(0,0,0,0))
sd(c(log(1), log(1), log(1)))
log(NA)
sd(log(1))
sd(NA, NA, NA, log(2))
sd(c(NA, NA, NA, log(2)))
sd(c(NA, NA, NA, log(2)), na.rm=TRUE)
pkgbuild::compile_dll() # see note below
roxygen2::roxygenise(load = "source")
pkgdown::build_site()
